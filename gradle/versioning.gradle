def generateVersionCode() {
    def splitVersion = rootProject.file('versioning/version').text.trim().split("\\.")
    def major = splitVersion[0].toInteger()
    def minor = splitVersion[1].toInteger()
    def patch = splitVersion[2].toInteger()
    def rc = rootProject.file('versioning/rc').text.trim().toInteger()

    def build
    if (rc > 0) {
        build = rc + 40
    } else {
        build = rootProject.file('versioning/nightly').text.trim().toInteger()
    }

    if (major < 0 || major > 99) {
        throw new IllegalArgumentException("major version is very large - are you sure you wanted to set it to this?")
    }
    if (minor < 0 || minor > 99) {
        throw new IllegalArgumentException("minor version is out of range")
    }
    if (patch < 0 || patch > 99) {
        throw new IllegalArgumentException("patch version is out of range")
    }
    if (build < 0 || build > 99) {
        throw new IllegalArgumentException("build version is out of range")
    }

    return major * 1_000_000 + minor * 10_000 + patch * 100 + build
}

def generateVersionName() {
    // Only look at the rc/nightly files if we're explicitly building a release.
    //
    // This ensures that we don't end up with a bunch of Firebase App Distribution builds with the
    // same version name as release train builds, which can be very confusing.
    //
    // We automatically publish a staging build every time there's a push to a branch with an open
    // PR (see .circle/config.yml). If the PR branch is based on a release branch (because it fixes
    // a bug in the release) and we *didn't* check this Gradle property, we'd end up automatically
    // publishing a staging build with the same version name as the most recent release train build
    // on the release branch.
    if (project.hasProperty('releaseVersionNames') ? releaseVersionNames.toBoolean() : false) {
        def splitVersion = rootProject.file('versioning/version').text.trim().split("\\.")
        def major = splitVersion[0].toInteger()
        def minor = splitVersion[1].toInteger()
        def patch = splitVersion[2].toInteger()
        def rc = rootProject.file('versioning/rc').text.trim().toInteger()

        if (rc > 0 && rc < 10) {
            // RC build.
            return "${major}.${minor}.${patch}-rc${rc}"
        }

        if (rc == 10) {
            // Final build.
            return "${major}.${minor}.${patch}"
        }

        // Nightly build.
        def nightly = rootProject.file('versioning/nightly').text.trim().toInteger()
        return "${major}.${minor}.${patch}-nightly${nightly}"
    }

    // Any other build.
    return "${gitBranch()}-${gitSha()}"
}

ext {
    generateVersionCode = this.&generateVersionCode
    generateVersionName = this.&generateVersionName
}

def gitBranch() {
    def cmd = 'git rev-parse --abbrev-ref HEAD'.execute([], project.rootDir)
    cmd.waitFor()
    if (cmd.exitValue() != 0) {
        throw new RuntimeException(cmd.errorStream.text)
    }

    return cmd.text.trim()
}

def gitSha() {
    def cmd = 'git rev-parse --short HEAD'.execute([], project.rootDir)
    cmd.waitFor()
    if (cmd.exitValue() != 0) {
        throw new RuntimeException(cmd.errorStream.text)
    }

    return cmd.text.trim()
}
